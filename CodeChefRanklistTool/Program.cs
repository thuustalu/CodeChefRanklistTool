using System;
using System.CommandLine;
using System.CommandLine.Invocation;
using System.IO;
using System.Text.Json;

namespace CodeChefRanklistTool
{
    public static class Program
    {
        public static void Main(string[] args)
        {
            var rootCommand = new RootCommand
            {
                new Option<InputFormat>("--inputFormat", () => InputFormat.Fetch,
                    "The source of the contest: 'Fetch' to download the contest from CodeChef, " +
                    "'Json' to parse the contest from json generated by this program."),
                new Option<OutputFormat>("--outputFormat", () => OutputFormat.Json | OutputFormat.Vjudge,
                    "The format of the output: 'Json' for a simple dump of downloaded data, 'Vjudge' for " +
                    "a vjudge replay xlsx (and a small text file with problem order and description hints."),
                new Option<string>("--fromCode", () => null,
                    "If inputFormat is 'Fetch', the CodeChef code of the contest " +
                    "to fetch. If inputFormat is 'Json', the file name."),
                new Option<string>("--fromList", () => null,
                    "Indicates that the argument is a file containing a list of " +
                    "input codes/filenames, all of which need to be processed."),
                new Option<VjudgeOverflowBehavior>("--onOverflow", () => VjudgeOverflowBehavior.Truncate,
                    "The behavior if vjudge's participant limit (2000) is exceeded: 'Truncate' indicates that " +
                    "only the top 2000 participants are shown; 'Sample' indicates that a random sample of " +
                    "2000 participants is picked. Json output is not affected."),
                new Option<int>("--penaltyTime", () => 10,
                    "The penalty time for a wrong submission for the contest.")
            };

            rootCommand.Handler =
                CommandHandler.Create<InputFormat, OutputFormat, string, string, VjudgeOverflowBehavior, int>(Process);

            rootCommand.InvokeAsync(args).GetAwaiter().GetResult();
        }

        private static void Process(InputFormat inputFormat, OutputFormat outputFormat, string fromCode,
            string fromList,
            VjudgeOverflowBehavior overflowBehavior, int penaltyTime)
        {
            if (!string.IsNullOrEmpty(fromCode) && !string.IsNullOrEmpty(fromList))
            {
                Console.WriteLine("'--fromCode' and '--fromList' can not be simultaneously set!");
                return;
            }

            if (string.IsNullOrEmpty(fromCode) && string.IsNullOrEmpty(fromList))
            {
                Console.WriteLine("At least one of '--fromCode' and '--fromList' must be set!");
                return;
            }

            if (!string.IsNullOrEmpty(fromCode))
            {
                Process(inputFormat, outputFormat, fromCode, overflowBehavior, penaltyTime);
            }
            else
            {
                var lines = File.ReadAllLines(fromList);
                foreach (var line in lines) Process(inputFormat, outputFormat, line, overflowBehavior, penaltyTime);
            }
        }

        private static void Process(InputFormat inputFormat, OutputFormat outputFormat, string fromCode,
            VjudgeOverflowBehavior overflowBehavior, int penaltyTime)
        {
            RanklistResponse response;
            switch (inputFormat)
            {
                case InputFormat.Fetch:
                    var requester = new RanklistRequester();
                    response = requester.GetRanklistAsync(fromCode).GetAwaiter().GetResult();
                    break;
                case InputFormat.Json:
                    var jsonText = File.ReadAllText(fromCode);
                    response = JsonSerializer.Deserialize<RanklistResponse>(jsonText);
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(inputFormat));
            }

            var dirPath = response.Contest.ContestCode;
            Directory.CreateDirectory(dirPath); // doesn't do anything if they already exist!

            if ((outputFormat & OutputFormat.Json) > 0)
            {
                var outputJson = JsonSerializer.Serialize(response);
                File.WriteAllText(Path.Combine(dirPath, "raw.json"), outputJson);
            }

            if ((outputFormat & OutputFormat.Vjudge) > 0)
            {
                var exporter = new VjudgeExporter(overflowBehavior, TimeSpan.FromMinutes(penaltyTime));
                exporter.Export(response, dirPath);
            }
        }

        private enum InputFormat
        {
            Fetch,
            Json
        }

        [Flags]
        private enum OutputFormat
        {
            Json = 1,
            Vjudge = 2
        }
    }
}